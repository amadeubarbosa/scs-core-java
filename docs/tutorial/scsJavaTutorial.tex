\documentclass[12pt]{article}

%% Estilos e Plug-Ins
\usepackage{a4}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{color}
\usepackage{epsfig}
\usepackage{mwlabinputs}

\setlength{\parskip}{6mm}
\textheight=8.2in

\def\lstlistingname{Código}
\lstset{inputencoding=latin1}

\newcommand{\code}[1]{\texttt{#1}}


% ===================
% Inicio do documento
% ===================

\begin{document} 

\title{Tutorial Básico do SDK Java do SCS}
\author{Tecgraf \\
        Pontifícia Universidade Católica do Rio de Janeiro (PUC-Rio)\\
        scs-users@tecgraf.puc-rio.br}

\date{}
\maketitle


\pagenumbering{arabic}

\section{Introdução}

Este documento é um tutorial básico sobre a criação de componentes no modelo
SCS v1.2, utilizando a versão Java da implementação padrão. Não serão
encontradas aqui explicações sobre o modelo, as quais encontram-se em
documentos específicos. Também não será abordado o uso de serviços específicos
desenvolvidos para o auxílio ao uso do modelo, como a infra-estrutura de
execução. Essas informações também podem ser obtidas em outros documentos.

A implementação Java baseia-se na versão 1.5 da máquina virtual Java e em CORBA
v2.3, representada pelo ORB Jacorb v3.3 que está incluso na implementação
padrão. Este documento assume que o leitor é familiarizado a conceitos de
desenvolvimento de \emph{software} baseado em componentes e à terminologia
CORBA.

\section{Inicialização do ORB}

Para a criação e execução do código de um componente, é necessária a
inicialização prévia de um ORB.
A instância de ORB criada será passada posteriormente para o construtor de um
componente SCS.
O procedimento deve ser feito de acordo com o código do Código~\ref{lst:orb_init}.

\begin{labeledcode}[java]{orb_init}{Criação do ORB}

public static void main(String[] args) {
  Properties props = new Properties();
  orbProps.setProperty("org.omg.CORBA.ORBClass", "org.jacorb.orb.ORB");
  orbProps.setProperty("org.omg.CORBA.ORBSingletonClass", "org.jacorb.orb.ORBSingleton");

  ORB orb = ORB.init(args, props);
}

\end{labeledcode}

\section{Passos Necessários à Criação de um Componente}

Aqui serão descritos os passos mínimos necessários para a criação de um
componente SCS.

\subsection{Definição do Identificador do Componente}\label{sec:componentid}

O identificador do componente é uma estrutura definida em IDL (scs.idl) chamada
\emph{ComponentId}, e representada em Java pela classe \emph{scs.core.ComponentId}. Um
identificador de componente conta com os seguintes campos:

\begin{itemize}
	\item \code{name}: Nome desejado para o componente.
	\item \code{major\_version}: Número que define a versão principal do
componente.
	\item \code{minor\_version}: Número que define a versão secundária do
componente, possivelmente relacionado a uma sub-versão da versão principal.
	\item \code{patch\_version}: Número que define a versão de revisão do
componente.
	\item \code{platform\_spec}: \emph{String} contendo quaisquer especificações de
plataforma necessárias ao funcionamento do componente.
\end{itemize}

Os números de versão do componente, quando unificados, devem ser separados por
pontos. Ou seja, um componente com versão principal 1, versão secundária 0 e
versão de revisão 0 deve ser representado como a \emph{String} "1.0.0".

\subsection{Criação do Componente Básico}\label{contexto}

Todo componente SCS é representado por seu "contexto".
Um Contexto de Componente atua como um invólucro local para as facetas e
receptáculos de um componente SCS.

O contexto é implementado pela classe scs.core.ComponentContext e seu processo
de instanciação engloba a criação de implementações padronizadas para as três
facetas básicas: \emph{IComponent}, \emph{IReceptacles} e \emph{IMetaInterface}.
Caso o usuário tenha a necessidade de utilizar uma implementação diferente de alguma dessas facetas, deve executar o método do contexto responsável pela atualização de facetas chamado \emph{updateFacet}.
O método \emph{updateFacet}  será descrito na Seção~\ref{lst:criacao_facetas}.

Como o contexto é quem cria os objetos CORBA, é necessário que tenha acesso a um \emph{ORB} e a um \emph{POA} logo em sua construção, para que possa inserir as facetas básicas e também facetas adicionais, posteriormente.
Outro parâmetro obrigatório é o Identificador do Componente (\ref{sec:componentid}).

Um exemplo de código para a criação de um componente básico pode ser visto no
Código~\ref{lst:criacao_contexto}.

\begin{labeledcode}[java]{criacao_contexto}{Instanciação de um Novo Componente}

public static void main(String[] args) {
  Properties props = new Properties();
  orbProps.setProperty("org.omg.CORBA.ORBClass", "org.jacorb.orb.ORB");
  orbProps.setProperty("org.omg.CORBA.ORBSingletonClass", "org.jacorb.orb.ORBSingleton");
  ORB orb = ORB.init(args, props);

  org.omg.CORBA.Object obj = orb.resolve_initial_references("RootPOA");
  POA poa = POAHelper.narrow(obj);

  ComponentId componentId =
    new ComponentId("MyComponent", (byte) 1, (byte) 0, (byte) 0, "java");
  ComponentContext context = new ComponentContext(orb, poa, componentId);
}

\end{labeledcode}
\subsection{Criação de Facetas}\label{criacao_facetas}

Facetas são interfaces CORBA, e devem ser implementadas por classes definidas
pelo usuário, como exigido pelas definições Java desse padrão.
Um exemplo de implementação de faceta pode ser conferido no Código~\ref{lst:criacao_facetas}.
Essa faceta precisa ter uma especificação em IDL.
Para o nosso exemplo, utilizaremos a IDL contida no Código~\ref{lst:idl}.

\begin{labeledcode}[java]{criacao_facetas}{Implementação de uma Faceta MyFacet}

public class MyFacetServant extends MyFacetPOA {
  public void myMethod() {
  }
}

\end{labeledcode}

\begin{labeledcode}[idl]{idl}{Exemplo de IDL de uma Faceta}
module mymodule{
  interface MyFacet {
    void myMethod();
  };
  interface AnotherFacet {
    void anotherMethod();
  };
};
\end{labeledcode}

Essa implementação posteriormente poderá ser instanciada e inserida em um componente como uma nova faceta.
Para adicionar uma nova faceta a um componente, o contexto fornece o método \emph{addFacet}, que espera como parâmetros o nome, a interface e a implementação da faceta.
O uso desse método pode ser visto no Código~\ref{lst:add_facet}.

\begin{labeledcode}[java]{add_facet}{Adição de uma Faceta MyFacet a um Componente}

ComponentContext context = ...
MyFacetServant facetServant = new MyFacetServant();
context.addFacet("MyFacetName", MyFacetHelper.id(), facetServant);

\end{labeledcode}

Por fim, é possível substituir a implementação de uma faceta por uma diferente.
Isso é feito através do método \emph{updateFacet}.
O método remove a faceta antiga e adiciona a nova, mas mantém o nome e a interface.
O Código~\ref{lst:update_facet} mostra o uso do método.

\begin{labeledcode}[java]{update_facet}{Atualização de uma Faceta Básica}

ComponentContext context = ...
MyIComponentServant facetServant = new MyIComponentServant();
context.updateFacet("IComponent", facetServant);

\end{labeledcode}

É importante notar que deve-ser tomar grande cuidado ao atualizar ou remover uma faceta (existe também um método \emph{removeFacet} que não é coberto neste tutorial, mas explicado na documentação da API), pois esses tipos de ação podem levar a resultados inesperados para clientes.
Isso pode ser considerado até mesmo como uma mudança em sua própria identidade.
Portanto, é recomendada a atualização ou remoção de facetas apenas na fase de construção ou destruição do componente, sem que suas facetas sejam conhecidas ou estejam sendo utilizadas pelos clientes.
Um cuidado ainda maior deve ser tomado em casos onde sejam utilizadas referências persistentes.

\subsection{Criação de Receptáculos}\label{receptaculos}

Receptáculos representam dependências de interfaces (facetas), e devem ser descritos pelo desenvolvedor da aplicação, não implementados.
Eles são manipulados pela faceta básica \emph{IReceptacles}.
Se a aplicação desejar manipular seus receptáculos de forma diferente, precisará substituir a implementação da faceta \emph{IReceptacles} através do método \emph{updateFacet} do contexto, como descrito na Seção \ref{criacao_facetas}.

A criação de receptáculos é muito parecida com a de facetas, descrita na Seção \ref{facetas}.
Para adicionar um receptáculo a um componente, o contexto fornece o método \emph{addReceptacle}, que espera como parâmetros o nome, a interface esperada e um \emph{boolean} indicando se o receptáculo deve aceitar múltiplas conexões ou somente uma.
O uso desse método pode ser visto no Código~\ref{lst:addReceptacle}.

\begin{labeledcode}[lua]{addReceptacle}{Adição de um Receptáculo MyReceptacle a um Componente}

ComponentContext context = ...
MyFacetServant facetServant = new MyFacetServant();
context.addReceptacle("MyReceptacleName", MyFacetHelper.id(), true);

\end{labeledcode}

\subsection{Acesso a Facetas e Receptáculos}\label{acesso}

O contexto fornece métodos para o acesso às suas facetas e receptáculos.
O acesso pode ser feito através do nome da faceta ou do receptáculo ou obtendo-se todos de uma vez.
Os métodos responsáveis por essas operações são: \emph{getFacetByName}, \emph{getReceptacleByName}, \emph{getFacets}, \emph{getReceptacles}.

\section{Exemplo Completo}

Demonstraremos aqui o uso mais simples de um componente: apenas uma faceta além das três facetas básicas. Não será criado nenhum receptáculo, apesar da existência da faceta \emph{IReceptacles}. Esta demonstração será baseada na \emph{demo} \emph{Hello}, e exemplos mais complexos poderão ser encontrados nas outras \emph{demos} do projeto.

O componente \emph{Hello} oferece quatro interfaces: \emph{IComponent}, \emph{IReceptacles}, \emph{IMetaInterface} e apenas uma interface própria, de nome \emph{IHello}. Sua IDL está disponível no Código~\ref{lst:helloidl}.

\begin{labeledcode}[idl]{helloidl}{IDL do Componente Hello}
module scs{
  module demos{
    module helloworld {
      interface Hello {
        void sayHello();
      };
    };
  };
};
\end{labeledcode}

O Código~\ref{lst:helloservant} implementa a faceta \emph{IHello}, que conta com apenas um método, \emph{sayHello}.
Logo em seguida, o Código~\ref{lst:hellomain} realiza a criação do componente.
O código é bastante similar ao apresentado na Seção \ref{criacao_facetas}.

\begin{labeledcode}[java]{helloservant}{A Faceta Hello}

public class HelloServant extends HelloPOA {
  private String name = "World";

  public void setName(String name) {
    this.name = name;
  }

  public void sayHello() {
    System.out.println("Hello " + name + "!");
  }

  @Override
  public org.omg.CORBA.Object _get_component() {
    return myComponent.getIComponent();
  }
}

\end{labeledcode}

\begin{labeledcode}[java]{hellomain}{Criação do Componente Hello}
  
public static void main(String[] args) {
  try {
    Properties props = new Properties();
    orbProps.setProperty("org.omg.CORBA.ORBClass", "org.jacorb.orb.ORB");
    orbProps.setProperty("org.omg.CORBA.ORBSingletonClass", "org.jacorb.orb.ORBSingleton");

    ORB orb = ORB.init(args, props);

    POA poa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
    poa.the_POAManager().activate();

    ComponentId componentId =
      new ComponentId("Hello", (byte) 1, (byte) 0, (byte) 0, "java");
    ComponentContext context = new ComponentContext(orb, poa, componentId);

    HelloServant helloImpl = new HelloServant();
    helloImpl.setName("User");
    context.addFacet("Hello", HelloHelper.id(), helloImpl);
    
    orb.run();
  }
  catch (Exception e) {
    e.printStackTrace();
    System.exit(1);
  }
}

\end{labeledcode}

Por fim, temos o código "cliente", que acessa o componente. Note que esse código
pode ser CORBA puro, não é necessária a criação de um componente para acessar
outro componente. Um exemplo desse tipo de código pode ser visto na
Listagem~\ref{lst:helloclient}.

\begin{labeledcode}[java]{helloclient}{Utilização do Componente Hello}
public static void main(String[] args) {
  try {
    Properties props = new Properties();
    orbProps.setProperty("org.omg.CORBA.ORBClass", "org.jacorb.orb.ORB");
    orbProps.setProperty("org.omg.CORBA.ORBSingletonClass", "org.jacorb.orb.ORBSingleton");

    ORB orb = ORB.init(args, props);

    String iHelloIOR = ...

    Hello iHelloFacet = HelloHelper.narrow(orb.string_to_object(iHelloIOR));
    IComponent icFacet = IComponentHelper.narrow(iHelloFacet._get_component());

    icFacet.startup();

    iHelloFacet.sayHello();
  }
  catch (Exception e) {
    e.printStackTrace();
    System.exit(1);
  }
}
\end{labeledcode}

Neste exemplo, a mensagem ``Hello User!'' será exibida somente na máquina
servidor. O código cliente apenas terá a chamada \emph{sayHello()} completada
corretamente e será finalizado sem erros.

\section{Elementos Adicionais da API do SCS}\label{adicionais}

As seções anteriores descreveram o uso mais comum do SCS para o desenvolvimento de aplicações baseadas em componentes. No entanto, alguns tópicos e funcionalidades adicionais merecem destaque. Nesta seção descreveremos os mais importantes, que podem ser necessários em aplicações ligeiramente mais complexas que o código apresentado anteriormente.

\subsubsection{Extensão do Contexto}\label{extcontexto}

Em particular, o contexto pode ser usado para guardar o estado do componente como um todo, armazenando informações que sejam úteis para mais de uma faceta.
A classe \emph{ComponentContext} já faz isso, guardando todas as informações sobre as facetas e receptáculos.
Se o usuário desejar inserir novos dados nessa classe, o ideal é estendê-la.

\subsubsection{Extensão de Facetas}\label{extfaceta}

Além do exemplo do contexto, é comum também encontrarmos a necessidade de estender classes que implementam facetas.
Por exemplo, a classe \emph{scs.core.IComponentServant}, que implementa a faceta \emph{IComponent}, contém métodos para gerenciar o ciclo de vida do componente, chamados \emph{startup} e \emph{shutdown}.
Como a lógica desses métodos deve ficar a cargo do desenvolvedor da aplicação, suas implementações não fazem nada.
Eles precisam ser sobrescritos com uma nova implementação.

\subsection{Builders}\label{builders}
Em todos os exemplos anteriores, a definição e "montagem" do componente (adição de facetas e receptáculos) é feita dentro do código fonte.
Isso significa que, caso seja necessária alguma mudança nessa configuração, o código-fonte precisa ser alterado.
É fácil perceber que essa configuração do componente pode ser definida externamente, permitindo alterações sem a necessidade de mudanças no código-fonte.

Além disso, serviços de mais alto nível podem se beneficiar de descrições em uma linguagem declarativa qualquer, para realizar a implantação automática de componentes num domínio. Administradores de sistema, sem um conhecimento maior sobre o desenvolvimento de componentes de \emph{software}, podem alterar a configuração de aplicações sem a necessidade da intervenção de um programador.

Para facilitar esse processo de externalização da configuração do componente, o SCS utiliza o conceito de \emph{builders}. \emph{Builders} são pequenas bibliotecas que lêem uma descrição de um componente em uma linguagem específica e então interpretam os dados para criar um componente de acordo com a configuração desejada. O SCS já fornece um \emph{builder} para a linguagem XML.

\subsubsection{XMLComponentBuilder}\label{xml}

O \emph{XMLComponentBuilder} interpreta um arquivo XML com a descrição de um componente e retorna um componente pronto com a configuração especificada nesse arquivo.
Na versão atual não é possível especificar parâmetros para os construtores das facetas. É possível especificar facetas, receptáculos, o Identificador do Componente e a implementação do contexto a ser usada.
O Código~\ref{lst:xml} mostra um XML de exemplo.

\begin{labeledcode}[xml]{xml}{Arquivo XML Definindo um Componente}
<?xml version="1.0" encoding="iso-8859-1" ?>
<component xmlns="tecgraf.scs">
  <id>
    <name>ExemploArquivoXML</name>
    <version>1.0.0</version>
    <platformSpec>Lua</platformSpec>
  </id>
  <context>
    <type>MyComponentContext</type>
  </context>
  <facets>
    <facet>
      <name>MyFacetName</name>
      <interfaceName>IDL:mymodule/MyFacet:1.0</interfaceName>
      <facetImpl>MyFacet</facetImpl>
    </facet>
    <facet>
      <name>AnotherFacet</name>
      <interfaceName>IDL:mymodule/AnotherFacet:1.0</interfaceName>
      <facetImpl>AnotherFacet</facetImpl>
    </facet>
  </facets>
  <receptacles>
    <receptacle>
      <name>MyReceptacleName</name>
      <interfaceName>IDL:mymodule/MyFacet:1.0</interfaceName>
      <isMultiplex>true</isMultiplex>
    </receptacle>
  </receptacles>
</component>
\end{labeledcode}

Para obter a implementação de facetas e contexto, o \emph{XMLComponentBuilder} carrega as classes através do mecanismo de reflexão de Java.
O construtor dessas implementações deve oferecer um construtor público que receba um \emph{ComponentContext}.
Se o nome de uma faceta já existir, a faceta anterior será substituída pela nova.

O SCS fornece em seu pacote de distribuição um arquivo chamado \emph{ComponentDescription.xsd} que contém o \emph{schema} XML utilizado pelo XMLComponentBuilder em qualquer linguagem suportada pelo SCS.

\end{document}
